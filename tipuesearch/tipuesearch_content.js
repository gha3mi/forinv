var tipuesearch = {"pages":[{"title":" ForInv ","text":"ForInv ForInv : A Fortran library for inverse and pseudo-inverse calculations. Requirements To use the forinv module, you need the following: Fortran compiler LAPACK or MKL fpm dependency If you want to use ForInv as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forinv = { git = \"https://github.com/gha3mi/forinv.git\" } Usage Here is an example of how to use the forinv module in your Fortran code: program main use kinds use forinv , only : pinv implicit none ! Declare variables real ( rk ), dimension (:, :), allocatable :: A , A_pinv ! Initialize matrix A ... ! Call pseudoinverse function A_pinv = pinv ( A ) end program main How to run tests and examples Clone the repository: You can clone the ForInv repository from GitHub using the following command: git clone https://github.com/gha3mi/forinv.git cd forinv Run tests: To set the stack size to unlimited, use the following command: ulimit -s unlimited . fpm @gfortran-test fpm @ifort-test fpm @ifx-test fpm @nvfortran-test API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForInv using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForInv are welcome! If you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"pinv_rel – ForInv","text":"private pure function pinv_rel(A, method, tol) result(Apinv) Calculates the pseudoinverse of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1)) Calls proc~~pinv_rel~~CallsGraph proc~pinv_rel forinv::pinv_rel proc~pinvlu_rel forinv::pinvLU_rel proc~pinv_rel->proc~pinvlu_rel proc~pinvsvd_rel forinv::pinvSVD_rel proc~pinv_rel->proc~pinvsvd_rel proc~gemm forinv::gemm proc~pinvlu_rel->proc~gemm proc~invlu_rel forinv::invLU_rel proc~pinvlu_rel->proc~invlu_rel svd svd proc~pinvsvd_rel->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pinv_rel~~CalledByGraph proc~pinv_rel forinv::pinv_rel interface~inv forinv::inv interface~inv->proc~pinv_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code pinv_rel Source Code pure function pinv_rel ( A , method , tol ) result ( Apinv ) #elif defined (IMPURE) impure function pinv_rel ( A , method , tol ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: method ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A if ( present ( method )) then select case ( method ) case ( 'gesvd' , 'gesdd' ) Apinv = pinvSVD_rel ( A , method , tol ) case ( 'getrf' ) Apinv = pinvLU_rel ( A ) case default error stop 'method is not valid.' end select else Apinv = pinvSVD_rel ( A , tol = tol ) end if end function pinv_rel","tags":"","loc":"proc/pinv_rel.html"},{"title":"pinvSVD_rel – ForInv","text":"private pure function pinvSVD_rel(A, method, tol) result(Apinv) Calculates the pseudoinverse of a matrix A using the SVD. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1)) Calls proc~~pinvsvd_rel~~CallsGraph proc~pinvsvd_rel forinv::pinvSVD_rel svd svd proc~pinvsvd_rel->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pinvsvd_rel~~CalledByGraph proc~pinvsvd_rel forinv::pinvSVD_rel proc~pinv_rel forinv::pinv_rel proc~pinv_rel->proc~pinvsvd_rel interface~inv forinv::inv interface~inv->proc~pinv_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code pinvSVD_rel Source Code pure function pinvSVD_rel ( A , method , tol ) result ( Apinv ) #elif defined (IMPURE) impure function pinvSVD_rel ( A , method , tol ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: method ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A ! Local variables real ( rk ), dimension ( size ( A , 1 ), size ( A , 1 )) :: U ! Left singular vectors real ( rk ), dimension ( size ( A , 2 ), size ( A , 2 )) :: VT ! Right singular vectors real ( rk ), dimension ( min ( size ( A , 1 ), size ( A , 2 ))) :: S ! Singular values integer :: m , n , i , j , irank , rank m = size ( A , 1 ) n = size ( A , 2 ) call svd ( A , U , S , VT , method ) if (. not . present ( tol )) then rank = min ( m , n ) else rank = count ( S > tol ) end if Apinv = 0.0_rk do irank = 1 , rank do j = 1 , m do i = 1 , n Apinv ( i , j ) = Apinv ( i , j ) + VT ( irank , i ) * U ( j , irank ) / S ( irank ) end do end do end do end function pinvSVD_rel","tags":"","loc":"proc/pinvsvd_rel.html"},{"title":"pinvLU_rel – ForInv","text":"private pure function pinvLU_rel(A) result(Apinv) Calculates the pseudoinverse of a matrix A using the LU decomposition. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Return Value real(kind=rk), dimension(size(A,2), size(A,1)) Calls proc~~pinvlu_rel~~CallsGraph proc~pinvlu_rel forinv::pinvLU_rel proc~gemm forinv::gemm proc~pinvlu_rel->proc~gemm proc~invlu_rel forinv::invLU_rel proc~pinvlu_rel->proc~invlu_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pinvlu_rel~~CalledByGraph proc~pinvlu_rel forinv::pinvLU_rel proc~pinv_rel forinv::pinv_rel proc~pinv_rel->proc~pinvlu_rel interface~inv forinv::inv interface~inv->proc~pinv_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code pinvLU_rel Source Code pure function pinvLU_rel ( A ) result ( Apinv ) #elif defined (IMPURE) impure function pinvLU_rel ( A ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A if ( size ( A , 1 ) == size ( A , 2 )) then Apinv = invLU_rel ( A ) elseif ( size ( A , 1 ) > size ( A , 2 )) then Apinv = transpose ( A ) Apinv = gemm ( invLU_rel ( gemm ( Apinv , A )), Apinv ) else Apinv = transpose ( A ) Apinv = gemm ( Apinv , invLU_rel ( gemm ( A , Apinv ))) end if end function pinvLU_rel","tags":"","loc":"proc/pinvlu_rel.html"},{"title":"invLU_rel – ForInv","text":"private pure function invLU_rel(A) result(Ainv) Calculates the inverse of a matrix A using the LU decomposition. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Return Value real(kind=rk), dimension(size(A,2), size(A,1)) Called by proc~~invlu_rel~~CalledByGraph proc~invlu_rel forinv::invLU_rel proc~pinvlu_rel forinv::pinvLU_rel proc~pinvlu_rel->proc~invlu_rel proc~pinv_rel forinv::pinv_rel proc~pinv_rel->proc~pinvlu_rel interface~inv forinv::inv interface~inv->proc~pinv_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code invLU_rel Source Code pure function invLU_rel ( A ) result ( Ainv ) #elif defined (IMPURE) impure function invLU_rel ( A ) result ( Ainv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Ainv ! Inverse of A ! Local variables integer :: ipiv ( size ( A , 1 )), info real ( rk ) :: work ( size ( A , 2 )) ! External subroutine for calculating the inverse of a matrix A using the LU decomposition. interface #if defined (PURE) pure subroutine dgetrf ( f_m , f_n , f_a , f_lda , f_ipiv , f_info ) #elif defined (IMPURE) impure subroutine dgetrf ( f_m , f_n , f_a , f_lda , f_ipiv , f_info ) #endif import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda integer , intent ( out ) :: f_ipiv ( * ) integer , intent ( out ) :: f_info real ( rk ), intent ( inout ) :: f_a ( f_lda , * ) end subroutine dgetrf #if defined (PURE) pure subroutine dgetri ( f_n , f_a , f_lda , f_ipiv , f_work , f_lwork , f_info ) #elif defined (IMPURE) impure subroutine dgetri ( f_n , f_a , f_lda , f_ipiv , f_work , f_lwork , f_info ) #endif import rk integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda integer , intent ( in ) :: f_lwork integer , intent ( out ) :: f_ipiv ( * ) integer , intent ( out ) :: f_info real ( rk ), intent ( inout ) :: f_a ( f_lda , * ) real ( rk ), intent ( out ) :: f_work ( * ) end subroutine dgetri end interface Ainv = A call dgetrf ( size ( A , 1 ), size ( A , 2 ), Ainv , size ( A , 1 ), ipiv , info ) call dgetri ( size ( A , 2 ), Ainv , size ( A , 1 ), ipiv , work , size ( A , 2 ), info ) end function invLU_rel","tags":"","loc":"proc/invlu_rel.html"},{"title":"gemm – ForInv","text":"private pure function gemm(A, B) result(C) Calculates the matrix-matrix product of two matrices A and B. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Called by proc~~gemm~~CalledByGraph proc~gemm forinv::gemm proc~pinvlu_rel forinv::pinvLU_rel proc~pinvlu_rel->proc~gemm proc~pinv_rel forinv::pinv_rel proc~pinv_rel->proc~pinvlu_rel interface~inv forinv::inv interface~inv->proc~pinv_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code gemm Source Code pure function gemm ( A , B ) result ( C ) #elif defined (IMPURE) impure function gemm ( A , B ) result ( C ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B ! Input matrix B ! Outputs: real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! Matrix-matrix product of A and B ! Local variables integer :: m , n , k ! External subroutine for calculating the matrix-matrix product of two matrices A and B. interface #if defined (PURE) pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) #elif defined (IMPURE) impure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) #endif import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm","tags":"","loc":"proc/gemm.html"},{"title":"inv – ForInv","text":"private interface inv Calls interface~~inv~~CallsGraph interface~inv forinv::inv proc~pinv_rel forinv::pinv_rel interface~inv->proc~pinv_rel proc~pinvlu_rel forinv::pinvLU_rel proc~pinv_rel->proc~pinvlu_rel proc~pinvsvd_rel forinv::pinvSVD_rel proc~pinv_rel->proc~pinvsvd_rel proc~gemm forinv::gemm proc~pinvlu_rel->proc~gemm proc~invlu_rel forinv::invLU_rel proc~pinvlu_rel->proc~invlu_rel svd svd proc~pinvsvd_rel->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures pinv_rel Module Procedures private pure function pinv_rel (A, method, tol) result(Apinv) Author Seyed Ali Ghasemi Calculates the pseudoinverse of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1))","tags":"","loc":"interface/inv.html"},{"title":"forinv – ForInv","text":"This module provides functions and subroutines for inverse and pseudo-inverse calculations. Uses kinds forsvd module~~forinv~~UsesGraph module~forinv forinv forsvd forsvd module~forinv->forsvd kinds kinds module~forinv->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forinv~~UsedByGraph module~forinv forinv program~test1 test1 program~test1->module~forinv program~test2 test2 program~test2->module~forinv program~test3 test3 program~test3->module~forinv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces inv Functions pinv_rel pinvSVD_rel pinvLU_rel invLU_rel gemm Interfaces private        interface inv private pure function pinv_rel (A, method, tol) result(Apinv) Author Seyed Ali Ghasemi Calculates the pseudoinverse of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1)) Functions private pure function pinv_rel (A, method, tol) result(Apinv) Author Seyed Ali Ghasemi Calculates the pseudoinverse of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1)) private pure function pinvSVD_rel (A, method, tol) result(Apinv) Author Seyed Ali Ghasemi Calculates the pseudoinverse of a matrix A using the SVD. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A character(len=*), intent(in), optional :: method real(kind=rk), intent(in), optional :: tol Return Value real(kind=rk), dimension(size(A,2), size(A,1)) private pure function pinvLU_rel (A) result(Apinv) Author ZUO Zhihua, Seyed Ali Ghasemi Calculates the pseudoinverse of a matrix A using the LU decomposition. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Return Value real(kind=rk), dimension(size(A,2), size(A,1)) private pure function invLU_rel (A) result(Ainv) Author ZUO Zhihua, Seyed Ali Ghasemi Calculates the inverse of a matrix A using the LU decomposition. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Return Value real(kind=rk), dimension(size(A,2), size(A,1)) private pure function gemm (A, B) result(C) Author ZUO Zhihua, Seyed Ali Ghasemi Calculates the matrix-matrix product of two matrices A and B. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2))","tags":"","loc":"module/forinv.html"},{"title":"test3 – ForInv","text":"Uses kinds fortime forinv program~~test3~~UsesGraph program~test3 test3 fortime fortime program~test3->fortime kinds kinds program~test3->kinds module~forinv forinv program~test3->module~forinv module~forinv->kinds forsvd forsvd module~forinv->forsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A Ainv m n w Source Code test3 Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:,:), allocatable :: Ainv integer :: m integer :: n type(timer) :: w Source Code program test3 ! This Fortran test code demonstrates the usage of the inv function to calculate the matrix inverse ! of a randomly generated matrix. use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module use fortime implicit none real ( rk ), dimension (:,:), allocatable :: A , Ainv ! Define dynamically allocated matrices A and Ainv integer :: m , n ! Define variables for matrix dimensions type ( timer ) :: w ! Define a watchtype object for timing measurements m = 2000 ! Set the number of rows for matrix A n = 200 ! Set the number of columns for matrix A allocate ( A ( m , n )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 call timer_start ( w ) Ainv = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function call timer_stop ( w , message = ' Elapsed time (2000*200 , gesvd):' ) call timer_start ( w ) Ainv = inv ( A * 10 , method = 'getrf' ) ! Calculate the matrix inverse of A using the 'inv' function and the getrf method call timer_stop ( w , message = ' Elapsed time (2000*200 , getrf):' ) deallocate ( Ainv ) ! Deallocate memory for matrix Ainv deallocate ( A ) ! Deallocate memory for matrix A m = 2000 ! Set the number of rows for matrix A n = 1800 ! Set the number of columns for matrix A allocate ( A ( m , n )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 call timer_start ( w ) Ainv = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function call timer_stop ( w , message = ' Elapsed time (2000*1800, gesvd):' ) call timer_start ( w ) Ainv = inv ( A * 10 , method = 'getrf' ) ! Calculate the matrix inverse of A using the 'inv' function and the getrf method call timer_stop ( w , message = ' Elapsed time (2000*1800, getrf):' ) deallocate ( Ainv ) ! Deallocate memory for matrix Ainv deallocate ( A ) ! Deallocate memory for matrix A print * , \"Test 3 passed.\" end program test3","tags":"","loc":"program/test3.html"},{"title":"test1 – ForInv","text":"Uses kinds forinv program~~test1~~UsesGraph program~test1 test1 kinds kinds program~test1->kinds module~forinv forinv program~test1->module~forinv module~forinv->kinds forsvd forsvd module~forinv->forsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A Ainv AinvM rel_err Source Code test1 Variables Type Attributes Name Initial real(kind=rk), dimension(4,3) :: A real(kind=rk), dimension(3,4) :: Ainv real(kind=rk), dimension(3,4) :: AinvM real(kind=rk) :: rel_err Source Code program test1 ! This Fortran test code demonstrates the usage of the inv function to calculate the matrix inverse& ! and verifies the results by comparing them with expected values obtained from MATLAB. use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module implicit none real ( rk ), dimension ( 4 , 3 ) :: A ! Define a 4x3 matrix A real ( rk ), dimension ( 3 , 4 ) :: Ainv , AinvM ! Define matrices Ainv and AinvM real ( rk ) :: rel_err !=============================================================================== ! Initialize matrix A with values A ( 1 , 1 ) = 0.814723686393179_rk ; A ( 1 , 2 ) = 0.632359246225410_rk ; A ( 1 , 3 ) = 0.957506835434298_rk A ( 2 , 1 ) = 0.905791937075619_rk ; A ( 2 , 2 ) = 0.0975404049994095_rk ; A ( 2 , 3 ) = 0.964888535199277_rk A ( 3 , 1 ) = 0.126986816293506_rk ; A ( 3 , 2 ) = 0.278498218867048_rk ; A ( 3 , 3 ) = 0.157613081677548_rk A ( 4 , 1 ) = 0.913375856139019_rk ; A ( 4 , 2 ) = 0.546881519204984_rk ; A ( 4 , 3 ) = 0.970592781760616_rk !=============================================================================== !=============================================================================== ! Define expected matrix AinvM=inv(A) from MATLAB results AinvM ( 1 , 1 ) = - 1 1.8748418966254_rk ; AinvM ( 1 , 2 ) = - 1.88508351433968_rk ; AinvM ( 1 , 3 ) = 1.37910840173057_rk ; AinvM ( 1 , 4 ) = 1 3.3647936345720_rk AinvM ( 2 , 1 ) = - 0.232262684677810_rk ; AinvM ( 2 , 2 ) = - 1.81026044323168_rk ; AinvM ( 2 , 3 ) = 1.12793815267075_rk ; AinvM ( 2 , 4 ) = 1.84558847033752_rk AinvM ( 3 , 1 ) = 1 1.2481704396877_rk ; AinvM ( 3 , 2 ) = 2.87726069020400_rk ; AinvM ( 3 , 3 ) = - 1.70926059704099_rk ; AinvM ( 3 , 4 ) = - 1 2.6490061903496_rk !=============================================================================== !=============================================================================== ! Calculate the matrix inverse of A using the 'inv' function Ainv = inv ( A ) !=============================================================================== !=============================================================================== ! Calculate the relative error between MATLAB and Fortran results rel_err = norm2 ( Ainv - AinvM ) / norm2 ( AinvM ) print * , \"Relative error:\" , rel_err if ( rel_err < 1e-13_rk ) then print * , \"Test 1 passed.\" print * , \"\" else print * , \"Test 1 failed!\" print * , \"\" end if !=============================================================================== end program test1","tags":"","loc":"program/test1.html"},{"title":"test2 – ForInv","text":"Uses kinds forinv program~~test2~~UsesGraph program~test2 test2 kinds kinds program~test2->kinds module~forinv forinv program~test2->module~forinv module~forinv->kinds forsvd forsvd module~forinv->forsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A Ainv1 Ainv2 m n rel_err Source Code test2 Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:,:), allocatable :: Ainv1 real(kind=rk), dimension(:,:), allocatable :: Ainv2 integer :: m integer :: n real(kind=rk) :: rel_err Source Code program test2 use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module implicit none real ( rk ), dimension (:,:), allocatable :: A , Ainv1 , Ainv2 ! Define dynamically allocated matrices A and Ainv integer :: m , n ! Define variables for matrix dimensions real ( rk ) :: rel_err m = 1000 ! Set the number of rows for matrix A n = 100 ! Set the number of columns for matrix A allocate ( A ( m , n ), Ainv1 ( n , m ), Ainv2 ( n , m )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 Ainv1 = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function Ainv2 = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function rel_err = norm2 ( Ainv1 - Ainv2 ) / norm2 ( Ainv1 ) print * , \"Ainv1(1,1) =\" , Ainv1 ( 1 , 1 ) print * , \"Ainv2(1,1) =\" , Ainv2 ( 1 , 1 ) print * , \"Relative error:\" , rel_err if ( rel_err < 1e-13_rk ) then print * , \"Test 2 passed.\" print * , \"\" else print * , \"Test 2 failed!\" print * , \"\" end if deallocate ( Ainv1 , Ainv2 ) ! Deallocate memory for matrix Ainv end program test2","tags":"","loc":"program/test2.html"},{"title":"forinv.f90 – ForInv","text":"Files dependent on this one sourcefile~~forinv.f90~~AfferentGraph sourcefile~forinv.f90 forinv.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~forinv.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~forinv.f90 sourcefile~test3.f90 test3.f90 sourcefile~test3.f90->sourcefile~forinv.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules forinv Source Code forinv.f90 Source Code module forinv !! This module provides functions and subroutines for inverse and pseudo-inverse calculations. use kinds use forsvd , only : svd implicit none private public :: pinv !=============================================================================== interface inv procedure :: pinv_rel end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> Calculates the pseudoinverse of a matrix A. #if defined (PURE) pure function pinv_rel ( A , method , tol ) result ( Apinv ) #elif defined (IMPURE) impure function pinv_rel ( A , method , tol ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: method ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A if ( present ( method )) then select case ( method ) case ( 'gesvd' , 'gesdd' ) Apinv = pinvSVD_rel ( A , method , tol ) case ( 'getrf' ) Apinv = pinvLU_rel ( A ) case default error stop 'method is not valid.' end select else Apinv = pinvSVD_rel ( A , tol = tol ) end if end function pinv_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Calculates the pseudoinverse of a matrix A using the SVD. #if defined (PURE) pure function pinvSVD_rel ( A , method , tol ) result ( Apinv ) #elif defined (IMPURE) impure function pinvSVD_rel ( A , method , tol ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: method ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A ! Local variables real ( rk ), dimension ( size ( A , 1 ), size ( A , 1 )) :: U ! Left singular vectors real ( rk ), dimension ( size ( A , 2 ), size ( A , 2 )) :: VT ! Right singular vectors real ( rk ), dimension ( min ( size ( A , 1 ), size ( A , 2 ))) :: S ! Singular values integer :: m , n , i , j , irank , rank m = size ( A , 1 ) n = size ( A , 2 ) call svd ( A , U , S , VT , method ) if (. not . present ( tol )) then rank = min ( m , n ) else rank = count ( S > tol ) end if Apinv = 0.0_rk do irank = 1 , rank do j = 1 , m do i = 1 , n Apinv ( i , j ) = Apinv ( i , j ) + VT ( irank , i ) * U ( j , irank ) / S ( irank ) end do end do end do end function pinvSVD_rel !=============================================================================== !=============================================================================== !> author: ZUO Zhihua, Seyed Ali Ghasemi !> Calculates the pseudoinverse of a matrix A using the LU decomposition. #if defined (PURE) pure function pinvLU_rel ( A ) result ( Apinv ) #elif defined (IMPURE) impure function pinvLU_rel ( A ) result ( Apinv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Apinv ! Pseudoinverse of A if ( size ( A , 1 ) == size ( A , 2 )) then Apinv = invLU_rel ( A ) elseif ( size ( A , 1 ) > size ( A , 2 )) then Apinv = transpose ( A ) Apinv = gemm ( invLU_rel ( gemm ( Apinv , A )), Apinv ) else Apinv = transpose ( A ) Apinv = gemm ( Apinv , invLU_rel ( gemm ( A , Apinv ))) end if end function pinvLU_rel !=============================================================================== !=============================================================================== !> author: ZUO Zhihua, Seyed Ali Ghasemi !> Calculates the inverse of a matrix A using the LU decomposition. #if defined (PURE) pure function invLU_rel ( A ) result ( Ainv ) #elif defined (IMPURE) impure function invLU_rel ( A ) result ( Ainv ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension ( size ( A , 2 ), size ( A , 1 )) :: Ainv ! Inverse of A ! Local variables integer :: ipiv ( size ( A , 1 )), info real ( rk ) :: work ( size ( A , 2 )) ! External subroutine for calculating the inverse of a matrix A using the LU decomposition. interface #if defined (PURE) pure subroutine dgetrf ( f_m , f_n , f_a , f_lda , f_ipiv , f_info ) #elif defined (IMPURE) impure subroutine dgetrf ( f_m , f_n , f_a , f_lda , f_ipiv , f_info ) #endif import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda integer , intent ( out ) :: f_ipiv ( * ) integer , intent ( out ) :: f_info real ( rk ), intent ( inout ) :: f_a ( f_lda , * ) end subroutine dgetrf #if defined (PURE) pure subroutine dgetri ( f_n , f_a , f_lda , f_ipiv , f_work , f_lwork , f_info ) #elif defined (IMPURE) impure subroutine dgetri ( f_n , f_a , f_lda , f_ipiv , f_work , f_lwork , f_info ) #endif import rk integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda integer , intent ( in ) :: f_lwork integer , intent ( out ) :: f_ipiv ( * ) integer , intent ( out ) :: f_info real ( rk ), intent ( inout ) :: f_a ( f_lda , * ) real ( rk ), intent ( out ) :: f_work ( * ) end subroutine dgetri end interface Ainv = A call dgetrf ( size ( A , 1 ), size ( A , 2 ), Ainv , size ( A , 1 ), ipiv , info ) call dgetri ( size ( A , 2 ), Ainv , size ( A , 1 ), ipiv , work , size ( A , 2 ), info ) end function invLU_rel !=============================================================================== !=============================================================================== !> author: ZUO Zhihua, Seyed Ali Ghasemi !> Calculates the matrix-matrix product of two matrices A and B. #if defined (PURE) pure function gemm ( A , B ) result ( C ) #elif defined (IMPURE) impure function gemm ( A , B ) result ( C ) #endif ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B ! Input matrix B ! Outputs: real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! Matrix-matrix product of A and B ! Local variables integer :: m , n , k ! External subroutine for calculating the matrix-matrix product of two matrices A and B. interface #if defined (PURE) pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) #elif defined (IMPURE) impure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) #endif import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm !=============================================================================== end module forinv","tags":"","loc":"sourcefile/forinv.f90.html"},{"title":"test3.f90 – ForInv","text":"This file depends on sourcefile~~test3.f90~~EfferentGraph sourcefile~test3.f90 test3.f90 sourcefile~forinv.f90 forinv.f90 sourcefile~test3.f90->sourcefile~forinv.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs test3 Source Code test3.f90 Source Code program test3 ! This Fortran test code demonstrates the usage of the inv function to calculate the matrix inverse ! of a randomly generated matrix. use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module use fortime implicit none real ( rk ), dimension (:,:), allocatable :: A , Ainv ! Define dynamically allocated matrices A and Ainv integer :: m , n ! Define variables for matrix dimensions type ( timer ) :: w ! Define a watchtype object for timing measurements m = 2000 ! Set the number of rows for matrix A n = 200 ! Set the number of columns for matrix A allocate ( A ( m , n )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 call timer_start ( w ) Ainv = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function call timer_stop ( w , message = ' Elapsed time (2000*200 , gesvd):' ) call timer_start ( w ) Ainv = inv ( A * 10 , method = 'getrf' ) ! Calculate the matrix inverse of A using the 'inv' function and the getrf method call timer_stop ( w , message = ' Elapsed time (2000*200 , getrf):' ) deallocate ( Ainv ) ! Deallocate memory for matrix Ainv deallocate ( A ) ! Deallocate memory for matrix A m = 2000 ! Set the number of rows for matrix A n = 1800 ! Set the number of columns for matrix A allocate ( A ( m , n )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 call timer_start ( w ) Ainv = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function call timer_stop ( w , message = ' Elapsed time (2000*1800, gesvd):' ) call timer_start ( w ) Ainv = inv ( A * 10 , method = 'getrf' ) ! Calculate the matrix inverse of A using the 'inv' function and the getrf method call timer_stop ( w , message = ' Elapsed time (2000*1800, getrf):' ) deallocate ( Ainv ) ! Deallocate memory for matrix Ainv deallocate ( A ) ! Deallocate memory for matrix A print * , \"Test 3 passed.\" end program test3","tags":"","loc":"sourcefile/test3.f90.html"},{"title":"test1.f90 – ForInv","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~forinv.f90 forinv.f90 sourcefile~test1.f90->sourcefile~forinv.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs test1 Source Code test1.f90 Source Code program test1 ! This Fortran test code demonstrates the usage of the inv function to calculate the matrix inverse& ! and verifies the results by comparing them with expected values obtained from MATLAB. use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module implicit none real ( rk ), dimension ( 4 , 3 ) :: A ! Define a 4x3 matrix A real ( rk ), dimension ( 3 , 4 ) :: Ainv , AinvM ! Define matrices Ainv and AinvM real ( rk ) :: rel_err !=============================================================================== ! Initialize matrix A with values A ( 1 , 1 ) = 0.814723686393179_rk ; A ( 1 , 2 ) = 0.632359246225410_rk ; A ( 1 , 3 ) = 0.957506835434298_rk A ( 2 , 1 ) = 0.905791937075619_rk ; A ( 2 , 2 ) = 0.0975404049994095_rk ; A ( 2 , 3 ) = 0.964888535199277_rk A ( 3 , 1 ) = 0.126986816293506_rk ; A ( 3 , 2 ) = 0.278498218867048_rk ; A ( 3 , 3 ) = 0.157613081677548_rk A ( 4 , 1 ) = 0.913375856139019_rk ; A ( 4 , 2 ) = 0.546881519204984_rk ; A ( 4 , 3 ) = 0.970592781760616_rk !=============================================================================== !=============================================================================== ! Define expected matrix AinvM=inv(A) from MATLAB results AinvM ( 1 , 1 ) = - 1 1.8748418966254_rk ; AinvM ( 1 , 2 ) = - 1.88508351433968_rk ; AinvM ( 1 , 3 ) = 1.37910840173057_rk ; AinvM ( 1 , 4 ) = 1 3.3647936345720_rk AinvM ( 2 , 1 ) = - 0.232262684677810_rk ; AinvM ( 2 , 2 ) = - 1.81026044323168_rk ; AinvM ( 2 , 3 ) = 1.12793815267075_rk ; AinvM ( 2 , 4 ) = 1.84558847033752_rk AinvM ( 3 , 1 ) = 1 1.2481704396877_rk ; AinvM ( 3 , 2 ) = 2.87726069020400_rk ; AinvM ( 3 , 3 ) = - 1.70926059704099_rk ; AinvM ( 3 , 4 ) = - 1 2.6490061903496_rk !=============================================================================== !=============================================================================== ! Calculate the matrix inverse of A using the 'inv' function Ainv = inv ( A ) !=============================================================================== !=============================================================================== ! Calculate the relative error between MATLAB and Fortran results rel_err = norm2 ( Ainv - AinvM ) / norm2 ( AinvM ) print * , \"Relative error:\" , rel_err if ( rel_err < 1e-13_rk ) then print * , \"Test 1 passed.\" print * , \"\" else print * , \"Test 1 failed!\" print * , \"\" end if !=============================================================================== end program test1","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"test2.f90 – ForInv","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~forinv.f90 forinv.f90 sourcefile~test2.f90->sourcefile~forinv.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs test2 Source Code test2.f90 Source Code program test2 use kinds ! Import the module 'kinds' for precision types use forinv , only : inv ! Import only the 'inv' function from the 'forinv' module implicit none real ( rk ), dimension (:,:), allocatable :: A , Ainv1 , Ainv2 ! Define dynamically allocated matrices A and Ainv integer :: m , n ! Define variables for matrix dimensions real ( rk ) :: rel_err m = 1000 ! Set the number of rows for matrix A n = 100 ! Set the number of columns for matrix A allocate ( A ( m , n ), Ainv1 ( n , m ), Ainv2 ( n , m )) ! Allocate memory for matrix A call random_number ( A ) ! Fill matrix A with random numbers between 0 and 1 Ainv1 = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function Ainv2 = inv ( A * 10 ) ! Calculate the matrix inverse of A using the 'inv' function rel_err = norm2 ( Ainv1 - Ainv2 ) / norm2 ( Ainv1 ) print * , \"Ainv1(1,1) =\" , Ainv1 ( 1 , 1 ) print * , \"Ainv2(1,1) =\" , Ainv2 ( 1 , 1 ) print * , \"Relative error:\" , rel_err if ( rel_err < 1e-13_rk ) then print * , \"Test 2 passed.\" print * , \"\" else print * , \"Test 2 failed!\" print * , \"\" end if deallocate ( Ainv1 , Ainv2 ) ! Deallocate memory for matrix Ainv end program test2","tags":"","loc":"sourcefile/test2.f90.html"}]}